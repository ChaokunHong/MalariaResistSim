// Automatically generated by odin 1.2.5 - do not edit
#include <float.h>
#include <R.h>
#include <Rmath.h>
#include <Rinternals.h>
#include <stdbool.h>
#include <R_ext/Rdynload.h>
typedef struct model_internal {
  double AR0;
  double As0;
  double DR0;
  double Ds0;
  double fT;
  double initial_AR;
  double initial_As;
  double initial_DR;
  double initial_Ds;
  double initial_S;
  double initial_TR;
  double initial_Ts;
  double Lambda_R;
  double Lambda_s;
  double Phi;
  double rA;
  double rD;
  double rTR;
  double rTs;
  double S0;
  double TR0;
  double Ts0;
} model_internal;
model_internal* model_get_internal(SEXP internal_p, int closed_error);
static void model_finalise(SEXP internal_p);
SEXP model_create(SEXP user);
void model_initmod_desolve(void(* odeparms) (int *, double *));
SEXP model_contents(SEXP internal_p);
SEXP model_set_user(SEXP internal_p, SEXP user);
SEXP model_set_initial(SEXP internal_p, SEXP t_ptr, SEXP state_ptr, SEXP model_use_dde_ptr);
SEXP model_metadata(SEXP internal_p);
SEXP model_initial_conditions(SEXP internal_p, SEXP t_ptr);
void model_rhs(model_internal* internal, double t, double * state, double * dstatedt, double * output);
void model_rhs_dde(size_t neq, double t, double * state, double * dstatedt, void * internal);
void model_rhs_desolve(int * neq, double * t, double * state, double * dstatedt, double * output, int * np);
SEXP model_rhs_r(SEXP internal_p, SEXP t, SEXP state);
double user_get_scalar_double(SEXP user, const char *name,
                              double default_value, double min, double max);
int user_get_scalar_int(SEXP user, const char *name,
                        int default_value, double min, double max);
void user_check_values_double(double * value, size_t len,
                                  double min, double max, const char *name);
void user_check_values_int(int * value, size_t len,
                               double min, double max, const char *name);
void user_check_values(SEXP value, double min, double max,
                           const char *name);
SEXP user_list_element(SEXP list, const char *name);
double scalar_real(SEXP x, const char * name);
model_internal* model_get_internal(SEXP internal_p, int closed_error) {
  model_internal *internal = NULL;
  if (TYPEOF(internal_p) != EXTPTRSXP) {
    Rf_error("Expected an external pointer");
  }
  internal = (model_internal*) R_ExternalPtrAddr(internal_p);
  if (!internal && closed_error) {
    Rf_error("Pointer has been invalidated");
  }
  return internal;
}
void model_finalise(SEXP internal_p) {
  model_internal *internal = model_get_internal(internal_p, 0);
  if (internal_p) {
    R_Free(internal);
    R_ClearExternalPtr(internal_p);
  }
}
SEXP model_create(SEXP user) {
  model_internal *internal = (model_internal*) R_Calloc(1, model_internal);
  internal->AR0 = NA_REAL;
  internal->As0 = NA_REAL;
  internal->DR0 = NA_REAL;
  internal->Ds0 = NA_REAL;
  internal->fT = NA_REAL;
  internal->Lambda_R = NA_REAL;
  internal->Lambda_s = NA_REAL;
  internal->Phi = NA_REAL;
  internal->rA = NA_REAL;
  internal->rD = NA_REAL;
  internal->rTR = NA_REAL;
  internal->rTs = NA_REAL;
  internal->S0 = NA_REAL;
  internal->TR0 = NA_REAL;
  internal->Ts0 = NA_REAL;
  SEXP ptr = PROTECT(R_MakeExternalPtr(internal, R_NilValue, R_NilValue));
  R_RegisterCFinalizer(ptr, model_finalise);
  UNPROTECT(1);
  return ptr;
}
static model_internal *model_internal_ds;
void model_initmod_desolve(void(* odeparms) (int *, double *)) {
  static DL_FUNC get_desolve_gparms = NULL;
  if (get_desolve_gparms == NULL) {
    get_desolve_gparms =
      R_GetCCallable("deSolve", "get_deSolve_gparms");
  }
  model_internal_ds = model_get_internal(get_desolve_gparms(), 1);
}
SEXP model_contents(SEXP internal_p) {
  model_internal *internal = model_get_internal(internal_p, 1);
  SEXP contents = PROTECT(allocVector(VECSXP, 22));
  SET_VECTOR_ELT(contents, 0, ScalarReal(internal->AR0));
  SET_VECTOR_ELT(contents, 1, ScalarReal(internal->As0));
  SET_VECTOR_ELT(contents, 2, ScalarReal(internal->DR0));
  SET_VECTOR_ELT(contents, 3, ScalarReal(internal->Ds0));
  SET_VECTOR_ELT(contents, 4, ScalarReal(internal->fT));
  SET_VECTOR_ELT(contents, 5, ScalarReal(internal->initial_AR));
  SET_VECTOR_ELT(contents, 6, ScalarReal(internal->initial_As));
  SET_VECTOR_ELT(contents, 7, ScalarReal(internal->initial_DR));
  SET_VECTOR_ELT(contents, 8, ScalarReal(internal->initial_Ds));
  SET_VECTOR_ELT(contents, 9, ScalarReal(internal->initial_S));
  SET_VECTOR_ELT(contents, 10, ScalarReal(internal->initial_TR));
  SET_VECTOR_ELT(contents, 11, ScalarReal(internal->initial_Ts));
  SET_VECTOR_ELT(contents, 12, ScalarReal(internal->Lambda_R));
  SET_VECTOR_ELT(contents, 13, ScalarReal(internal->Lambda_s));
  SET_VECTOR_ELT(contents, 14, ScalarReal(internal->Phi));
  SET_VECTOR_ELT(contents, 15, ScalarReal(internal->rA));
  SET_VECTOR_ELT(contents, 16, ScalarReal(internal->rD));
  SET_VECTOR_ELT(contents, 17, ScalarReal(internal->rTR));
  SET_VECTOR_ELT(contents, 18, ScalarReal(internal->rTs));
  SET_VECTOR_ELT(contents, 19, ScalarReal(internal->S0));
  SET_VECTOR_ELT(contents, 20, ScalarReal(internal->TR0));
  SET_VECTOR_ELT(contents, 21, ScalarReal(internal->Ts0));
  SEXP nms = PROTECT(allocVector(STRSXP, 22));
  SET_STRING_ELT(nms, 0, mkChar("AR0"));
  SET_STRING_ELT(nms, 1, mkChar("As0"));
  SET_STRING_ELT(nms, 2, mkChar("DR0"));
  SET_STRING_ELT(nms, 3, mkChar("Ds0"));
  SET_STRING_ELT(nms, 4, mkChar("fT"));
  SET_STRING_ELT(nms, 5, mkChar("initial_AR"));
  SET_STRING_ELT(nms, 6, mkChar("initial_As"));
  SET_STRING_ELT(nms, 7, mkChar("initial_DR"));
  SET_STRING_ELT(nms, 8, mkChar("initial_Ds"));
  SET_STRING_ELT(nms, 9, mkChar("initial_S"));
  SET_STRING_ELT(nms, 10, mkChar("initial_TR"));
  SET_STRING_ELT(nms, 11, mkChar("initial_Ts"));
  SET_STRING_ELT(nms, 12, mkChar("Lambda_R"));
  SET_STRING_ELT(nms, 13, mkChar("Lambda_s"));
  SET_STRING_ELT(nms, 14, mkChar("Phi"));
  SET_STRING_ELT(nms, 15, mkChar("rA"));
  SET_STRING_ELT(nms, 16, mkChar("rD"));
  SET_STRING_ELT(nms, 17, mkChar("rTR"));
  SET_STRING_ELT(nms, 18, mkChar("rTs"));
  SET_STRING_ELT(nms, 19, mkChar("S0"));
  SET_STRING_ELT(nms, 20, mkChar("TR0"));
  SET_STRING_ELT(nms, 21, mkChar("Ts0"));
  setAttrib(contents, R_NamesSymbol, nms);
  UNPROTECT(2);
  return contents;
}
SEXP model_set_user(SEXP internal_p, SEXP user) {
  model_internal *internal = model_get_internal(internal_p, 1);
  internal->AR0 = user_get_scalar_double(user, "AR0", internal->AR0, NA_REAL, NA_REAL);
  internal->As0 = user_get_scalar_double(user, "As0", internal->As0, NA_REAL, NA_REAL);
  internal->DR0 = user_get_scalar_double(user, "DR0", internal->DR0, NA_REAL, NA_REAL);
  internal->Ds0 = user_get_scalar_double(user, "Ds0", internal->Ds0, NA_REAL, NA_REAL);
  internal->fT = user_get_scalar_double(user, "fT", internal->fT, NA_REAL, NA_REAL);
  internal->Lambda_R = user_get_scalar_double(user, "Lambda_R", internal->Lambda_R, NA_REAL, NA_REAL);
  internal->Lambda_s = user_get_scalar_double(user, "Lambda_s", internal->Lambda_s, NA_REAL, NA_REAL);
  internal->Phi = user_get_scalar_double(user, "Phi", internal->Phi, NA_REAL, NA_REAL);
  internal->rA = user_get_scalar_double(user, "rA", internal->rA, NA_REAL, NA_REAL);
  internal->rD = user_get_scalar_double(user, "rD", internal->rD, NA_REAL, NA_REAL);
  internal->rTR = user_get_scalar_double(user, "rTR", internal->rTR, NA_REAL, NA_REAL);
  internal->rTs = user_get_scalar_double(user, "rTs", internal->rTs, NA_REAL, NA_REAL);
  internal->S0 = user_get_scalar_double(user, "S0", internal->S0, NA_REAL, NA_REAL);
  internal->TR0 = user_get_scalar_double(user, "TR0", internal->TR0, NA_REAL, NA_REAL);
  internal->Ts0 = user_get_scalar_double(user, "Ts0", internal->Ts0, NA_REAL, NA_REAL);
  internal->initial_AR = internal->AR0;
  internal->initial_As = internal->As0;
  internal->initial_DR = internal->DR0;
  internal->initial_Ds = internal->Ds0;
  internal->initial_S = internal->S0;
  internal->initial_TR = internal->TR0;
  internal->initial_Ts = internal->Ts0;
  return R_NilValue;
}
SEXP model_set_initial(SEXP internal_p, SEXP t_ptr, SEXP state_ptr, SEXP model_use_dde_ptr) {
  return R_NilValue;
}
SEXP model_metadata(SEXP internal_p) {
  model_internal *internal = model_get_internal(internal_p, 1);
  SEXP ret = PROTECT(allocVector(VECSXP, 4));
  SEXP nms = PROTECT(allocVector(STRSXP, 4));
  SET_STRING_ELT(nms, 0, mkChar("variable_order"));
  SET_STRING_ELT(nms, 1, mkChar("output_order"));
  SET_STRING_ELT(nms, 2, mkChar("n_out"));
  SET_STRING_ELT(nms, 3, mkChar("interpolate_t"));
  setAttrib(ret, R_NamesSymbol, nms);
  SEXP variable_length = PROTECT(allocVector(VECSXP, 7));
  SEXP variable_names = PROTECT(allocVector(STRSXP, 7));
  setAttrib(variable_length, R_NamesSymbol, variable_names);
  SET_VECTOR_ELT(variable_length, 0, R_NilValue);
  SET_VECTOR_ELT(variable_length, 1, R_NilValue);
  SET_VECTOR_ELT(variable_length, 2, R_NilValue);
  SET_VECTOR_ELT(variable_length, 3, R_NilValue);
  SET_VECTOR_ELT(variable_length, 4, R_NilValue);
  SET_VECTOR_ELT(variable_length, 5, R_NilValue);
  SET_VECTOR_ELT(variable_length, 6, R_NilValue);
  SET_STRING_ELT(variable_names, 0, mkChar("S"));
  SET_STRING_ELT(variable_names, 1, mkChar("Ds"));
  SET_STRING_ELT(variable_names, 2, mkChar("As"));
  SET_STRING_ELT(variable_names, 3, mkChar("Ts"));
  SET_STRING_ELT(variable_names, 4, mkChar("DR"));
  SET_STRING_ELT(variable_names, 5, mkChar("AR"));
  SET_STRING_ELT(variable_names, 6, mkChar("TR"));
  SET_VECTOR_ELT(ret, 0, variable_length);
  UNPROTECT(2);
  SET_VECTOR_ELT(ret, 1, R_NilValue);
  SET_VECTOR_ELT(ret, 2, ScalarInteger(0));
  UNPROTECT(2);
  return ret;
}
SEXP model_initial_conditions(SEXP internal_p, SEXP t_ptr) {
  model_internal *internal = model_get_internal(internal_p, 1);
  SEXP r_state = PROTECT(allocVector(REALSXP, 7));
  double * state = REAL(r_state);
  state[0] = internal->initial_S;
  state[1] = internal->initial_Ds;
  state[2] = internal->initial_As;
  state[3] = internal->initial_Ts;
  state[4] = internal->initial_DR;
  state[5] = internal->initial_AR;
  state[6] = internal->initial_TR;
  UNPROTECT(1);
  return r_state;
}
void model_rhs(model_internal* internal, double t, double * state, double * dstatedt, double * output) {
  double S = state[0];
  double Ds = state[1];
  double As = state[2];
  double Ts = state[3];
  double DR = state[4];
  double AR = state[5];
  double TR = state[6];
  dstatedt[5] = S * internal->Lambda_R * (1 - internal->Phi) + DR * internal->rD - internal->Lambda_R * AR * internal->Phi * (1 - internal->fT) - internal->Lambda_R * AR * internal->Phi * internal->fT - AR * internal->rA;
  dstatedt[2] = S * internal->Lambda_s * (1 - internal->Phi) + Ds * internal->rD - internal->Lambda_s * As * internal->Phi * (1 - internal->fT) - internal->Lambda_s * As * internal->Phi * internal->fT - As * internal->rA;
  dstatedt[4] = S * internal->Lambda_R * internal->Phi * (1 - internal->fT) + internal->Lambda_R * AR * internal->Phi * (1 - internal->fT) - DR * internal->rD;
  dstatedt[1] = S * internal->Lambda_s * internal->Phi * (1 - internal->fT) + internal->Lambda_s * As * internal->Phi * (1 - internal->fT) - Ds * internal->rD;
  dstatedt[0] = -(S) * internal->Lambda_s * (internal->Phi * internal->fT + internal->Phi * (1 - internal->fT) + (1 - internal->Phi)) - S * internal->Lambda_R * (internal->Phi * internal->fT + internal->Phi * (1 - internal->fT) + (1 - internal->Phi)) + Ts * internal->rTs + As * internal->rA + AR * internal->rA + TR * internal->rTR;
  dstatedt[6] = S * internal->Lambda_R * internal->Phi * internal->fT + internal->Lambda_R * AR * internal->Phi * internal->fT - TR * internal->rTR;
  dstatedt[3] = S * internal->Lambda_s * internal->Phi * internal->fT + internal->Lambda_s * As * internal->Phi * internal->fT - Ts * internal->rTs;
}
void model_rhs_dde(size_t neq, double t, double * state, double * dstatedt, void * internal) {
  model_rhs((model_internal*)internal, t, state, dstatedt, NULL);
}
void model_rhs_desolve(int * neq, double * t, double * state, double * dstatedt, double * output, int * np) {
  model_rhs(model_internal_ds, *t, state, dstatedt, output);
}
SEXP model_rhs_r(SEXP internal_p, SEXP t, SEXP state) {
  SEXP dstatedt = PROTECT(allocVector(REALSXP, LENGTH(state)));
  model_internal *internal = model_get_internal(internal_p, 1);
  double *output = NULL;
  model_rhs(internal, scalar_real(t, "t"), REAL(state), REAL(dstatedt), output);
  UNPROTECT(1);
  return dstatedt;
}
double user_get_scalar_double(SEXP user, const char *name,
                              double default_value, double min, double max) {
  double ret = default_value;
  SEXP el = user_list_element(user, name);
  if (el != R_NilValue) {
    if (length(el) != 1) {
      Rf_error("Expected a scalar numeric for '%s'", name);
    }
    if (TYPEOF(el) == REALSXP) {
      ret = REAL(el)[0];
    } else if (TYPEOF(el) == INTSXP) {
      ret = INTEGER(el)[0];
    } else {
      Rf_error("Expected a numeric value for '%s'", name);
    }
  }
  if (ISNA(ret)) {
    Rf_error("Expected a value for '%s'", name);
  }
  user_check_values_double(&ret, 1, min, max, name);
  return ret;
}
int user_get_scalar_int(SEXP user, const char *name,
                        int default_value, double min, double max) {
  int ret = default_value;
  SEXP el = user_list_element(user, name);
  if (el != R_NilValue) {
    if (length(el) != 1) {
      Rf_error("Expected scalar integer for '%s'", name);
    }
    if (TYPEOF(el) == REALSXP) {
      double tmp = REAL(el)[0];
      if (fabs(tmp - round(tmp)) > 2e-8) {
        Rf_error("Expected '%s' to be integer-like", name);
      }
    }
    ret = INTEGER(coerceVector(el, INTSXP))[0];
  }
  if (ret == NA_INTEGER) {
    Rf_error("Expected a value for '%s'", name);
  }
  user_check_values_int(&ret, 1, min, max, name);
  return ret;
}
void user_check_values_double(double * value, size_t len,
                                  double min, double max, const char *name) {
  for (size_t i = 0; i < len; ++i) {
    if (ISNA(value[i])) {
      Rf_error("'%s' must not contain any NA values", name);
    }
  }
  if (min != NA_REAL) {
    for (size_t i = 0; i < len; ++i) {
      if (value[i] < min) {
        Rf_error("Expected '%s' to be at least %g", name, min);
      }
    }
  }
  if (max != NA_REAL) {
    for (size_t i = 0; i < len; ++i) {
      if (value[i] > max) {
        Rf_error("Expected '%s' to be at most %g", name, max);
      }
    }
  }
}
void user_check_values_int(int * value, size_t len,
                               double min, double max, const char *name) {
  for (size_t i = 0; i < len; ++i) {
    if (ISNA(value[i])) {
      Rf_error("'%s' must not contain any NA values", name);
    }
  }
  if (min != NA_REAL) {
    for (size_t i = 0; i < len; ++i) {
      if (value[i] < min) {
        Rf_error("Expected '%s' to be at least %g", name, min);
      }
    }
  }
  if (max != NA_REAL) {
    for (size_t i = 0; i < len; ++i) {
      if (value[i] > max) {
        Rf_error("Expected '%s' to be at most %g", name, max);
      }
    }
  }
}
void user_check_values(SEXP value, double min, double max,
                           const char *name) {
  size_t len = (size_t)length(value);
  if (TYPEOF(value) == INTSXP) {
    user_check_values_int(INTEGER(value), len, min, max, name);
  } else {
    user_check_values_double(REAL(value), len, min, max, name);
  }
}
SEXP user_list_element(SEXP list, const char *name) {
  SEXP ret = R_NilValue, names = getAttrib(list, R_NamesSymbol);
  for (int i = 0; i < length(list); ++i) {
    if (strcmp(CHAR(STRING_ELT(names, i)), name) == 0) {
      ret = VECTOR_ELT(list, i);
      break;
    }
  }
  return ret;
}
double scalar_real(SEXP x, const char * name) {
  if (Rf_length(x) != 1) {
    Rf_error("Expected a scalar for '%s'", name);
  }
  double ret = 0.0;
  if (TYPEOF(x) == INTSXP) {
    ret = INTEGER(x)[0];
  } else if (TYPEOF(x) == REALSXP) {
    ret = REAL(x)[0];
  } else {
    Rf_error("Expected a numeric value for '%s'", name);
  }
  return ret;
}
